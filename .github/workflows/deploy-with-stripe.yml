name: Deploy with Stripe Configuration

# NOTE: Tests are run against the live production API (https://www.autodevelop.ai)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  # API Configuration - Tests run against live production API
  API_BASE_URL: https://www.autodevelop.ai
  
  # Stripe Configuration - Use GitHub Environment Secrets
  STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
  STRIPE_PUBLISHABLE_KEY: ${{ secrets.STRIPE_PUBLISHABLE_KEY }}
  STRIPE_WEBHOOK_SECRET: ${{ secrets.STRIPE_WEBHOOK_SECRET }}
  
  # Stripe Pricing Configuration - Use GitHub Environment Secrets
  STRIPE_STARTER_PRICE_ID: ${{ secrets.STRIPE_STARTER_PRICE_ID }}
  STRIPE_STARTER_YEARLY_PRICE_ID: ${{ secrets.STRIPE_STARTER_YEARLY_PRICE_ID }}
  STRIPE_PRO_PRICE_ID: ${{ secrets.STRIPE_PRO_PRICE_ID }}
  STRIPE_PRO_YEARLY_PRICE_ID: ${{ secrets.STRIPE_PRO_YEARLY_PRICE_ID }}
  STRIPE_ENTERPRISE_PRICE_ID: ${{ secrets.STRIPE_ENTERPRISE_PRICE_ID }}
  STRIPE_ENTERPRISE_YEARLY_PRICE_ID: ${{ secrets.STRIPE_ENTERPRISE_YEARLY_PRICE_ID }}
  STRIPE_DEFAULT_PRICE_ID: ${{ secrets.STRIPE_DEFAULT_PRICE_ID }}
  
  # Stripe URLs - Can be configured per environment
  STRIPE_SUCCESS_URL: ${{ vars.STRIPE_SUCCESS_URL || 'https://autodevelop.ai/success' }}
  STRIPE_CANCEL_URL: ${{ vars.STRIPE_CANCEL_URL || 'https://autodevelop.ai/cancel' }}
  STRIPE_PORTAL_RETURN_URL: ${{ vars.STRIPE_PORTAL_RETURN_URL || 'https://autodevelop.ai/account' }}
  
  # Production API Keys
  OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

jobs:
  test-pricing:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm install
    
    - name: API Health Check
      run: |
        echo "üè• Performing API health check..."
        echo "üåê Testing API endpoint: ${{ env.API_BASE_URL }}/api/pricing/tiers"
        
        # Check if curl and jq are available
        if ! command -v curl >/dev/null 2>&1; then
          echo "‚ùå Error: curl is not available"
          exit 1
        fi
        
        if ! command -v jq >/dev/null 2>&1; then
          echo "‚ùå Error: jq is not available"
          exit 1
        fi
        
        # Set the API endpoint for health check
        API_ENDPOINT="${{ env.API_BASE_URL }}/api/pricing/tiers"
        
        # Perform health check with proper error handling
        echo "üì° Making request to API endpoint..."
        if ! HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/api_response.txt "$API_ENDPOINT" 2>/dev/null); then
          echo "‚ùå API Health Check Failed: Network Error"
          echo "üö® Could not connect to the API endpoint."
          echo "   This indicates a network connectivity issue or the API server is completely down."
          echo "   Stopping workflow to avoid running pointless tests."
          exit 1
        fi
        
        echo "üìä HTTP Response Code: $HTTP_CODE"
        
        # Check if we got a successful HTTP response
        if [ "$HTTP_CODE" != "200" ]; then
          echo "‚ùå API Health Check Failed: HTTP $HTTP_CODE"
          echo "üîç Response content:"
          head -10 /tmp/api_response.txt 2>/dev/null || echo "No response content"
          echo ""
          echo "üö® The API endpoint is not responding with HTTP 200."
          echo "   This indicates the API may be down, misconfigured, or returning error pages."
          echo "   Stopping workflow to avoid running pointless tests."
          exit 1
        fi
        
        # Check if the response is valid JSON
        echo "üîç Validating JSON response..."
        if ! jq empty /tmp/api_response.txt 2>/dev/null; then
          echo "‚ùå API Health Check Failed: Invalid JSON Response"
          echo "üîç Full response content:"
          cat /tmp/api_response.txt 2>/dev/null || echo "No response content"
          echo ""
          echo "üîç Response size: $(wc -c < /tmp/api_response.txt 2>/dev/null || echo '0') bytes"
          echo "üîç Response type detection:"
          
          # Check if it's HTML
          if grep -qi "<!DOCTYPE\|<html\|<body\|<div" /tmp/api_response.txt 2>/dev/null; then
            echo "   ‚Ä¢ Detected: HTML content (likely error page)"
          elif grep -qi "server error\|function_invocation_failed\|internal error" /tmp/api_response.txt 2>/dev/null; then
            echo "   ‚Ä¢ Detected: Server error message (likely Vercel function failure)"
          elif grep -qi "not found\|404" /tmp/api_response.txt 2>/dev/null; then
            echo "   ‚Ä¢ Detected: Not found error"
          else
            echo "   ‚Ä¢ Detected: Unknown non-JSON content"
          fi
          
          echo ""
          echo "üö® The API is returning HTML or invalid JSON instead of proper JSON response."
          echo "   This indicates the API endpoint may be down or misconfigured."
          echo "   Common causes:"
          echo "   ‚Ä¢ Vercel serverless function deployment failure"
          echo "   ‚Ä¢ Missing environment variables in production"
          echo "   ‚Ä¢ Code errors in the API handler"
          echo "   ‚Ä¢ Database connection issues"
          echo "   Stopping workflow to avoid running pointless tests."
          exit 1
        fi
        
        # Validate the JSON structure contains expected fields
        echo "‚úÖ JSON validation passed. Checking response structure..."
        if ! jq -e '.success' /tmp/api_response.txt >/dev/null 2>&1; then
          echo "‚ö†Ô∏è  Warning: Response doesn't contain 'success' field, but JSON is valid"
          echo "üîç Response structure:"
          jq '.' /tmp/api_response.txt 2>/dev/null | head -10 || echo "Could not parse response"
        else
          echo "‚úÖ Response contains expected 'success' field"
        fi
        
        echo "‚úÖ API Health Check Passed!"
        echo "   ‚Ä¢ HTTP 200 response received"
        echo "   ‚Ä¢ Valid JSON format confirmed"
        echo "   ‚Ä¢ API endpoint is responding correctly"
        echo ""
        
        # Clean up
        rm -f /tmp/api_response.txt
    
    - name: Run tests against live API
      run: |
        # Test pricing endpoints against live production API
        node test-pricing-tiers.js
      env:
        API_BASE_URL: ${{ env.API_BASE_URL }}
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
    
    - name: Validate Stripe configuration
      run: |
        if [ -z "$STRIPE_SECRET_KEY" ]; then
          echo "‚ùå STRIPE_SECRET_KEY not configured"
          exit 1
        fi
        
        if [ -z "$STRIPE_PRO_PRICE_ID" ]; then
          echo "‚ùå STRIPE_PRO_PRICE_ID not configured"
          exit 1
        fi
        
        echo "‚úÖ Essential Stripe environment variables are configured"

  deploy:
    needs: test-pricing
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Deploy to production
      run: |
        echo "üöÄ Deploying to production with Stripe pricing tiers..."
        # Add your deployment commands here
        # Example: Deploy to Vercel, Heroku, AWS, etc.
        
    - name: Notify deployment success
      run: |
        echo "‚úÖ Deployment successful with the following pricing configuration:"
        echo "   - Starter: \$9.99/month (Promo: \$7.99/month)"
        echo "   - Pro: \$19.99/month (Promo: \$14.99/month)" 
        echo "   - Enterprise: \$49.99/month (Promo: \$39.99/month)"